// Generated by CoffeeScript 1.6.3
(function() {
  var async, categories, channels, configs, debug, domains, error, express, fs, fstream, mkdirp, os, path, rimraf, runnables, tar, users, uuid, zlib;

  async = require('async');

  channels = require('../models/channels');

  categories = require('../models/categories');

  configs = require('../configs');

  debug = require('debug');

  domains = require('../domains');

  error = require('../error');

  express = require('express');

  fs = require('fs');

  fstream = require('fstream');

  mkdirp = require('mkdirp');

  os = require('os');

  path = require('path');

  users = require('../models/users');

  uuid = require('node-uuid');

  rimraf = require('rimraf');

  runnables = require('../models/runnables');

  tar = require('tar');

  zlib = require('zlib');

  module.exports = function(parentDomain) {
    var app;
    app = express();
    app.use(domains(parentDomain));
    app.post('/runnables/import', function(req, res) {
      var sync, tmpdir, uncompress, untar, writer;
      req.pause();
      tmpdir = "" + (os.tmpdir()) + "/" + (uuid.v4());
      fs.mkdirSync(tmpdir);
      uncompress = zlib.createUnzip();
      req.pipe(uncompress);
      untar = tar.Parse();
      uncompress.pipe(untar);
      writer = fstream.Writer({
        path: tmpdir
      });
      untar.pipe(writer);
      req.resume();
      if (req.query.sync === 'false') {
        sync = false;
      } else {
        sync = true;
      }
      return writer.on('close', function() {
        return fs.exists("" + tmpdir + "/runnable.json", function(exists) {
          if (exists) {
            return runnables.createImageFromDisk(req.domain, req.user_id, tmpdir, sync, function(err, runnable) {
              if (err) {
                return res.json(err.code, {
                  message: err.msg
                });
              } else {
                return rimraf(tmpdir, function(err) {
                  if (err) {
                    throw err;
                  }
                  return res.json(201, runnable);
                });
              }
            });
          } else {
            return fs.readdir(tmpdir, function(err, files) {
              var newPath;
              if (err) {
                throw err;
              }
              newPath = "" + tmpdir + "/" + files[0];
              return fs.exists("" + newPath + "/runnable.json", function(exists) {
                if (!exists) {
                  return res.json(403, {
                    message: 'could not find runnable.json'
                  });
                } else {
                  return runnables.createImageFromDisk(req.domain, req.user_id, newPath, sync, function(err, runnable) {
                    if (err) {
                      return res.json(err.code, {
                        message: err.msg
                      });
                    } else {
                      return rimraf(tmpdir, function(err) {
                        if (err) {
                          throw err;
                        }
                        return res.json(201, runnable);
                      });
                    }
                  });
                }
              });
            });
          }
        });
      });
    });
    app.get('/runnables/:id/export', function(req, res) {
      var baseTmpDir, tmpdir;
      baseTmpDir = "" + (os.tmpdir()) + "/" + (uuid.v4());
      fs.mkdirSync(baseTmpDir);
      tmpdir = "" + baseTmpDir + "/" + req.params.id;
      fs.mkdirSync(tmpdir);
      return runnables.getImage(req.domain, req.params.id, function(err, runnable) {
        var runnable_json;
        if (err) {
          return res.json(err.code, {
            message: err.msg
          });
        } else {
          runnable_json = {
            name: runnable.name,
            image: runnable.image,
            cmd: runnable.start_cmd,
            port: runnable.port,
            start_cmd: runnable.start_cmd,
            build_cmd: runnable.build_cmd,
            service_cmds: runnable.service_cmds,
            description: runnable.description,
            file_root: runnable.file_root,
            file_root_host: runnable.file_root_host
          };
          runnable_json.tags = [];
          runnable.tags.forEach(function(tag) {
            return runnable_json.tags.push({
              name: tag.name
            });
          });
          return fs.writeFile("" + tmpdir + "/Dockerfile", runnable.dockerfile, 'utf8', function(err) {
            if (err) {
              throw err;
            }
            return fs.mkdir("" + tmpdir + "/" + runnable.file_root_host, function(err) {
              if (err) {
                throw err;
              }
              return runnables.createContainer(req.domain, req.user_id, req.params.id, function(err, container) {
                if (err) {
                  return res.json(err.code, {
                    message: err.msg
                  });
                } else {
                  return runnables.listFiles(req.domain, req.user_id, container._id, true, void 0, void 0, void 0, function(err, files) {
                    if (err) {
                      return res.json(err.code, {
                        message: err.msg
                      });
                    } else {
                      runnable_json.files = [];
                      return async.forEach(files, function(file, cb) {
                        if (file.ignore || file["default"]) {
                          file.ignore = file.ignore || false;
                          file.dir = file.dir || false;
                          file["default"] = file["default"] || false;
                          runnable_json.files.push({
                            name: file.name,
                            path: file.path,
                            ignore: file.ignore,
                            "default": file["default"],
                            dir: file.dir
                          });
                        }
                        return mkdirp("" + tmpdir + "/" + runnable.file_root_host + file.path, function(err) {
                          if (err) {
                            throw err;
                          }
                          if (file.ignore) {
                            return cb();
                          } else {
                            if (file.dir) {
                              return fs.mkdir("" + tmpdir + "/" + runnable.file_root_host + file.path + "/" + file.name, function(err) {
                                if (err) {
                                  throw err;
                                }
                                return cb();
                              });
                            } else {
                              return fs.writeFile("" + tmpdir + "/" + runnable.file_root_host + file.path + "/" + file.name, file.content, 'utf8', function(err) {
                                if (err) {
                                  throw err;
                                }
                                return cb();
                              });
                            }
                          }
                        });
                      }, function(err) {
                        if (err) {
                          return res.json(err.code, {
                            message: err.msg
                          });
                        } else {
                          return fs.writeFile("" + tmpdir + "/runnable.json", JSON.stringify(runnable_json, void 0, 2), 'utf8', function(err) {
                            if (err) {
                              throw err;
                            }
                            return runnables.removeContainer(req.domain, req.user_id, container._id, function(err) {
                              var compress, packer, reader;
                              if (err) {
                                return res.json(err.code, {
                                  message: err.msg
                                });
                              } else {
                                tmpdir = path.resolve(tmpdir);
                                compress = zlib.createGzip();
                                packer = tar.Pack();
                                reader = fstream.Reader({
                                  path: tmpdir,
                                  type: 'Directory',
                                  mode: '0755'
                                });
                                reader.pause();
                                res.set('content-type', 'application/x-gzip');
                                compress.pipe(res);
                                packer.pipe(compress);
                                reader.pipe(packer);
                                res.on('end', function() {
                                  return rimraf(baseTmpDir, function(err) {
                                    if (err) {
                                      throw err;
                                    }
                                  });
                                });
                                return reader.resume();
                              }
                            });
                          });
                        }
                      });
                    }
                  });
                }
              });
            });
          });
        }
      });
    });
    return app;
  };

}).call(this);

/*
//@ sourceMappingURL=impexp.map
*/
