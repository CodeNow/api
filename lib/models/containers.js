// Generated by CoffeeScript 1.6.3
(function() {
  var ObjectId, Schema, async, cacheContents, configs, containerSchema, crypto, decodeId, encodeId, error, exts, implementations, minus, mongoose, path, plus, proxy, request, slash, sync, underscore, uuid, volumes, _,
    __indexOf = [].indexOf || function(item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item) {
          return i;
        }
      }
      return -1;
    };

  async = require('async');

  configs = require('../configs');

  crypto = require('crypto');

  error = require('../error');

  exts = require('../extensions');

  path = require('path');

  mongoose = require('mongoose');

  request = require('request');

  sync = require('./sync');

  uuid = require('node-uuid');

  volumes = require("./volumes");

  implementations = require('./implementations');

  _ = require('lodash');

  if (configs.dockworkerProxy) {
    proxy = configs.dockworkerProxy;
  }

  Schema = mongoose.Schema;

  ObjectId = Schema.ObjectId;

  containerSchema = new Schema({
    name: {
      type: String
    },
    description: {
      type: String,
      "default": ''
    },
    owner: {
      type: ObjectId,
      index: true
    },
    parent: {
      type: ObjectId,
      index: true
    },
    child: {
      type: ObjectId
    },
    created: {
      type: Date,
      "default": Date.now,
      index: true
    },
    target: {
      type: ObjectId
    },
    image: {
      type: String
    },
    dockerfile: {
      type: String
    },
    cmd: {
      type: String
    },
    port: {
      type: Number
    },
    servicesToken: {
      type: String
    },
    webToken: {
      type: String
    },
    tags: {
      type: [
        {
          channel: ObjectId
        }
      ],
      "default": []
    },
    service_cmds: {
      type: String,
      "default": ''
    },
    output_format: {
      type: String
    },
    saved: {
      type: Boolean,
      "default": false,
      index: true
    },
    start_cmd: {
      type: String,
      "default": 'date'
    },
    build_cmd: {
      type: String,
      "default": ''
    },
    last_write: {
      type: Date
    },
    file_root: {
      type: String,
      "default": '/root'
    },
    file_root_host: {
      type: String,
      "default": './src'
    },
    files: {
      type: [
        {
          name: {
            type: String
          },
          path: {
            type: String
          },
          dir: {
            type: Boolean
          },
          ignore: {
            type: Boolean
          },
          content: {
            type: String
          },
          "default": {
            type: Boolean,
            "default": false
          }
        }
      ],
      "default": []
    },
    specification: {
      type: ObjectId
    },
    status: {
      type: String,
      "default": 'Draft'
    },
    commit_error: {
      type: String,
      "default": ''
    }
  });

  containerSchema.set('toJSON', {
    virtuals: true
  });

  containerSchema.set('autoIndex', true);

  containerSchema.index({
    saved: 1,
    created: 1
  });

  containerSchema.index({
    tags: 1,
    parent: 1
  });

  containerSchema.statics.create = function(domain, owner, image, data, cb) {
    var _this = this;
    if (typeof data === 'function') {
      cb = data;
      data = {};
    }
    data = data != null ? data : {};
    return image.sync(domain, function() {
      var createContainer, env, servicesToken;
      servicesToken = 'services-' + uuid.v4();
      env = ["RUNNABLE_USER_DIR=" + image.file_root, "RUNNABLE_SERVICE_CMDS=" + image.service_cmds, "RUNNABLE_START_CMD=" + image.start_cmd, "RUNNABLE_BUILD_CMD=" + image.build_cmd, "SERVICES_TOKEN=" + servicesToken, "APACHE_RUN_USER=www-data", "APACHE_RUN_GROUP=www-data", "APACHE_LOG_DIR=/var/log/apache2", "PATH=/dart-sdk/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"];
      createContainer = function(env, subdomain) {
        var container, file, length, repo, revision, tag, _i, _j, _len, _len1, _ref, _ref1;
        container = new _this({
          parent: image,
          name: image.name,
          owner: owner,
          description: image.description,
          port: image.port,
          cmd: image.cmd,
          image: image.image,
          file_root: image.file_root,
          service_cmds: image.service_cmds,
          start_cmd: image.start_cmd,
          build_cmd: image.build_cmd,
          output_format: image.output_format,
          servicesToken: servicesToken,
          webToken: 'web-' + uuid.v4(),
          specification: image.specification
        });
        _ref = image.files;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          container.files.push(file.toJSON());
        }
        _ref1 = image.tags;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          tag = _ref1[_j];
          container.tags.push(tag.toJSON());
        }
        if (image.revisions && image.revisions.length) {
          length = image.revisions.length;
          revision = image.revisions[length - 1];
          repo = encodeId(revision.repo ? revision.repo : revision._id.toString());
        } else {
          repo = encodeId(image._id.toString());
        }
        _.extend(container, data);
        return request({
          url: "" + configs.harbourmaster + "/containers",
          method: 'POST',
          pool: false,
          json: {
            servicesToken: container.servicesToken,
            webToken: container.webToken,
            subdomain: subdomain,
            Env: env,
            Hostname: 'runnable',
            Image: "" + configs.dockerRegistry + "/runnable/" + repo,
            PortSpecs: [container.port.toString()],
            Cmd: [container.cmd]
          }
        }, domain.intercept(function(res) {
          return container.save(domain.intercept(function() {
            return cb(null, container);
          }));
        }));
      };
      if (image.specification != null) {
        return implementations.findOne({
          owner: owner,
          "implements": image.specification
        }, domain.intercept(function(implementation) {
          var envFull;
          if (implementation != null) {
            envFull = env.concat(implementation.toJSON().requirements.map(function(requirement) {
              return "" + requirement.name + "=" + requirement.value;
            }));
            envFull.push("BASE_URL=http://" + implementation.subdomain + "." + configs.domain);
            return createContainer(envFull, implementation.subdomain);
          } else {
            return createContainer(env);
          }
        }));
      } else {
        return createContainer(env);
      }
    });
  };

  containerSchema.statics.destroy = function(domain, id, cb) {
    var _this = this;
    return this.findOne({
      _id: id
    }, domain.intercept(function(container) {
      if (!container) {
        return cb(error(404, 'container not found'));
      } else {
        return request({
          url: "" + configs.harbourmaster + "/containers/" + container.servicesToken,
          method: 'DELETE',
          pool: false
        }, domain.intercept(function(res) {
          return _this.remove({
            _id: id
          }, domain.intercept(function() {
            return cb();
          }));
        }));
      }
    }));
  };

  containerSchema.statics.listSavedContainers = function(domain, cb) {
    var timeout;
    timeout = (new Date()).getTime() - configs.containerTimeout;
    return this.find({
      $or: [
        {
          saved: true
        }, {
          created: {
            $gte: timeout
          }
        }
      ]
    }, {
      files: 0
    }, domain.intercept(cb));
  };

  containerSchema.methods.updateRunOptions = function(domain, cb) {
    var operations, self;
    self = this;
    operations = [self.updateBuildCommand.bind(self, domain), self.updateStartCommand.bind(self, domain)];
    if (this.specification != null) {
      operations.push(self.updateEnvVariables.bind(self, domain));
    }
    return async.parallel(operations, cb);
  };

  containerSchema.methods.updateEnvVariables = function(domain, cb) {
    var encodedId;
    encodedId = encodeId(this._id);
    return implementations.updateEnvBySpecification(domain, {
      userId: this.owner,
      specification: this.specification,
      containerId: encodedId
    }, cb);
  };

  containerSchema.methods.updateBuildCommand = function(domain, cb) {
    var url;
    url = "http://" + this.servicesToken + "." + configs.domain + "/api/buildCmd";
    return request.post({
      url: url,
      pool: false,
      json: this.build_cmd,
      proxy: proxy
    }, domain.intercept(function() {
      return cb();
    }));
  };

  containerSchema.methods.updateStartCommand = function(domain, cb) {
    var url;
    url = "http://" + this.servicesToken + "." + configs.domain + "/api/cmd";
    return request.post({
      url: url,
      pool: false,
      json: this.start_cmd,
      proxy: proxy
    }, domain.intercept(function() {
      return cb();
    }));
  };

  containerSchema.methods.listFiles = function(domain, content, dir, default_tag, path, cb) {
    var files;
    files = [];
    if (default_tag) {
      content = true;
      this.files.forEach(function(file) {
        if (file["default"]) {
          if (!path || file.path === path) {
            return files.push(file.toJSON());
          }
        }
      });
    } else if (dir) {
      this.files.forEach(function(file) {
        if (file.dir) {
          if (!path || file.path === path) {
            return files.push(file.toJSON());
          }
        }
      });
    } else {
      this.files.forEach(function(file) {
        if (!path || file.path === path) {
          return files.push(file.toJSON());
        }
      });
    }
    if (!content) {
      files.forEach(function(file) {
        return delete file.content;
      });
    }
    return cb(null, files);
  };

  cacheContents = function(ext) {
    var _ref;
    return _ref = ext.toLowerCase(), __indexOf.call(exts, _ref) >= 0;
  };

  containerSchema.methods.syncFiles = function(domain, cb) {
    var _this = this;
    return sync(domain, this.servicesToken, this, function(err) {
      if (err) {
        return cb(err);
      } else {
        _this.last_write = new Date();
        return _this.save(domain.intercept(function() {
          return cb(null, _this);
        }));
      }
    });
  };

  containerSchema.methods.createFile = function(domain, name, filePath, content, cb) {
    var _this = this;
    filePath = path.normalize(filePath);
    if (typeof content === 'string') {
      return volumes.createFile(domain, this.servicesToken, this.file_root, name, filePath, content, function(err) {
        var ext, file;
        if (err) {
          return cb(err);
        } else {
          file = {
            path: filePath,
            name: name
          };
          ext = path.extname(name);
          if (cacheContents(ext)) {
            file.content = content;
          }
          _this.files.push(file);
          file = _this.files[_this.files.length - 1];
          _this.last_write = new Date();
          return _this.save(domain.intercept(function() {
            return cb(null, {
              _id: file._id,
              name: name,
              path: filePath
            });
          }));
        }
      });
    } else {
      return volumes.streamFile(domain, this.servicesToken, this.file_root, name, filePath, content, function(err) {
        var ext, file;
        if (err) {
          return cb(err);
        } else {
          file = {
            path: filePath,
            name: name
          };
          ext = path.extname(name);
          if (cacheContents(ext)) {
            return volumes.readFile(domain, _this.servicesToken, _this.file_root, name, filePath, function(err, file_content) {
              if (err) {
                return cb(err);
              } else {
                file.content = file_content;
                _this.files.push(file);
                file = _this.files[_this.files.length - 1];
                _this.last_write = new Date();
                return _this.save(domain.intercept(function() {
                  return cb(null, {
                    _id: file._id,
                    name: file.name,
                    path: file.path,
                    content: file.content
                  });
                }));
              }
            });
          } else {
            _this.files.push(file);
            file = _this.files[_this.files.length - 1];
            _this.last_write = new Date();
            return _this.save(domain.intercept(function() {
              return cb(null, {
                _id: file._id,
                name: file.name,
                path: file.path
              });
            }));
          }
        }
      });
    }
  };

  containerSchema.methods.updateFile = function(domain, fileId, content, cb) {
    var file,
      _this = this;
    file = this.files.id(fileId);
    if (!file) {
      return cb(error(404, 'file does not exist'));
    } else {
      return volumes.updateFile(domain, this.servicesToken, this.file_root, file.name, file.path, content, function(err) {
        var ext;
        if (err) {
          return cb(err);
        } else {
          ext = path.extname(file.name);
          if (cacheContents(ext)) {
            file.content = content;
          }
          _this.last_write = new Date();
          return _this.save(domain.intercept(function() {
            return cb(null, file);
          }));
        }
      });
    }
  };

  containerSchema.methods.updateFileContents = function(domain, filePath, content, cb) {
    var foundFile,
      _this = this;
    foundFile = null;
    filePath = path.normalize(filePath);
    this.files.forEach(function(file) {
      var elemPath;
      elemPath = path.normalize("" + file.path + "/" + file.name);
      if (elemPath === filePath) {
        foundFile = file;
      }
    });
    if (!foundFile) {
      return cb(error(404, 'file does not exist'));
    } else {
      return volumes.streamFile(domain, this.servicesToken, this.file_root, foundFile.name, foundFile.path, content, function(err) {
        var ext;
        if (err) {
          return cb(err);
        } else {
          ext = path.extname(foundFile.name);
          if (cacheContents(ext)) {
            return volumes.readFile(domain, _this.servicesToken, _this.file_root, foundFile.name, foundFile.path, function(err, file_content) {
              if (err) {
                return cb(err);
              } else {
                foundFile.content = file_content;
                _this.last_write = new Date();
                return _this.save(domain.intercept(function() {
                  return cb(null, {
                    _id: foundFile._id,
                    name: foundFile.name,
                    path: foundFile.path
                  });
                }));
              }
            });
          } else {
            _this.last_write = new Date();
            return _this.save(domain.intercept(function() {
              return cb(null, {
                _id: foundFile._id,
                name: foundFile.name,
                path: foundFile.path
              });
            }));
          }
        }
      });
    }
  };

  containerSchema.methods.renameFile = function(domain, fileId, newName, cb) {
    var file,
      _this = this;
    file = this.files.id(fileId);
    if (!file) {
      return cb(error(404, 'file does not exist'));
    } else {
      return volumes.renameFile(domain, this.servicesToken, this.file_root, file.name, file.path, newName, function(err) {
        var elem, newCached, newExt, newPath, oldCached, oldExt, oldName, oldPath, _i, _len, _ref;
        if (err) {
          return cb(err);
        } else {
          oldName = file.name;
          file.name = newName;
          if (file.dir) {
            oldPath = path.normalize("" + file.path + "/" + oldName);
            newPath = path.normalize("" + file.path + "/" + newName);
            _ref = _this.files;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              elem = _ref[_i];
              if (elem.path.indexOf(oldPath) === 0 && elem._id !== file._id) {
                elem.path = elem.path.replace(oldPath, newPath);
              }
            }
            _this.last_write = new Date();
            return _this.save(domain.intercept(function() {
              return cb(null, file);
            }));
          } else {
            oldExt = path.extname(oldName);
            newExt = path.extname(newName);
            oldCached = cacheContents(oldExt);
            newCached = cacheContents(newExt);
            if (oldCached && !newCached) {
              file.content = void 0;
              file["default"] = false;
            }
            if (!oldCached && newCached) {
              return volumes.readFile(domain, _this.servicesToken, _this.file_root, file.name, file.path, function(err, content) {
                if (err) {
                  return cb(err);
                } else {
                  file.content = content;
                  _this.last_write = new Date();
                  return _this.save(domain.intercept(function() {
                    return cb(null, file);
                  }));
                }
              });
            } else {
              _this.last_write = new Date();
              return _this.save(domain.intercept(function() {
                return cb(null, file);
              }));
            }
          }
        }
      });
    }
  };

  containerSchema.methods.moveFile = function(domain, fileId, newPath, cb) {
    var file,
      _this = this;
    file = this.files.id(fileId);
    newPath = path.normalize(newPath);
    if (!file) {
      return cb(error(404, 'file does not exist'));
    } else {
      return volumes.moveFile(domain, this.servicesToken, this.file_root, file.name, file.path, newPath, function(err) {
        var elem, oldPath, _i, _len, _ref;
        if (err) {
          return cb(err);
        } else {
          oldPath = file.path;
          file.path = newPath;
          if (file.dir) {
            oldPath = path.normalize("" + oldPath + "/" + file.name);
            newPath = path.normalize("" + newPath + "/" + file.name);
            _ref = _this.files;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              elem = _ref[_i];
              if (elem.path.indexOf(oldPath) === 0 && elem._id !== file._id) {
                elem.path = elem.path.replace(oldPath, newPath);
              }
            }
          }
          _this.last_write = new Date();
          return _this.save(domain.intercept(function() {
            return cb(null, file);
          }));
        }
      });
    }
  };

  containerSchema.methods.createDirectory = function(domain, name, path, cb) {
    var _this = this;
    return volumes.createDirectory(domain, this.servicesToken, this.file_root, name, path, function(err) {
      var file;
      if (err) {
        return cb(err);
      } else {
        _this.files.push({
          path: path,
          name: name,
          dir: true
        });
        file = _this.files[_this.files.length - 1];
        _this.last_write = new Date();
        return _this.save(domain.intercept(function() {
          return cb(null, file);
        }));
      }
    });
  };

  containerSchema.methods.readFile = function(domain, fileId, cb) {
    var file;
    file = this.files.id(fileId);
    if (!file) {
      return cb(error(404, 'file does not exist'));
    } else {
      return cb(null, file.toJSON());
    }
  };

  containerSchema.methods.tagFile = function(domain, fileId, isDefault, cb) {
    var file;
    file = this.files.id(fileId);
    if (!file) {
      return cb(error(404, 'file does not exist'));
    } else {
      if (file.dir) {
        return cb(error(403, 'cannot tag directory as default'));
      } else {
        if (!file.content && isDefault) {
          return cb(error(403, 'cannot tag an uncached file as default'));
        } else {
          file["default"] = isDefault;
          return this.save(domain.intercept(function() {
            return cb(null, file);
          }));
        }
      }
    }
  };

  containerSchema.methods.deleteFile = function(domain, fileId, recursive, cb) {
    var file,
      _this = this;
    file = this.files.id(fileId);
    if (!file) {
      return cb(error(404, 'file does not exist'));
    } else {
      if (!file.dir) {
        return volumes.deleteFile(domain, this.servicesToken, this.file_root, file.name, file.path, function(err) {
          if (err) {
            return cb(err);
          } else {
            file.remove();
            _this.last_write = new Date();
            return _this.save(domain.intercept(function() {
              return cb();
            }));
          }
        });
      } else {
        return volumes.removeDirectory(domain, this.servicesToken, this.file_root, file.name, file.path, recursive, function(err) {
          var elem, match, toDelete, _i, _j, _len, _len1, _ref;
          if (err) {
            return cb(err);
          } else {
            if (recursive) {
              toDelete = [];
              match = path.normalize("" + file.path + "/" + file.name);
              _ref = _this.files;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                elem = _ref[_i];
                if (elem.path.indexOf(match) === 0) {
                  toDelete.push(elem);
                }
              }
              for (_j = 0, _len1 = toDelete.length; _j < _len1; _j++) {
                elem = toDelete[_j];
                elem.remove();
              }
            }
            file.remove();
            _this.last_write = new Date();
            return _this.save(domain.intercept(function() {
              return cb();
            }));
          }
        });
      }
    }
  };

  containerSchema.methods.getMountedFiles = function(domain, fileId, mountDir, cb) {
    var file, subDir;
    file = this.files.id(fileId);
    if (!file) {
      return cb(error(404, 'file does not exist'));
    } else {
      if (!file.ignore) {
        return cb(error(403, 'entry is not a valid mount point'));
      } else {
        subDir = path.normalize("" + file.path + "/" + file.name + "/" + mountDir);
        return volumes.readDirectory(domain, this.servicesToken, this.file_root, subDir, exts, function(err, files) {
          if (err) {
            return cb(err);
          } else {
            return cb(null, files);
          }
        });
      }
    }
  };

  plus = /\+/g;

  slash = /\//g;

  minus = /-/g;

  underscore = /_/g;

  encodeId = function(id) {
    return id;
  };

  decodeId = function(id) {
    return id;
  };

  if (configs.shortProjectIds) {
    encodeId = function(id) {
      return (new Buffer(id.toString(), 'hex')).toString('base64').replace(plus, '-').replace(slash, '_');
    };
    decodeId = function(id) {
      return (new Buffer(id.toString().replace(minus, '+').replace(underscore, '/'), 'base64')).toString('hex');
    };
  }

  module.exports = mongoose.model('Containers', containerSchema);

}).call(this);

/*
//@ sourceMappingURL=containers.map
*/
